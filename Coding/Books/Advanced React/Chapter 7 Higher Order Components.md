_Higher Order Component_ is a function that accepts a component as one of its arguments, executes some logic, and then returns another component that renders the component from the argument.

```jsx
const withSomeLogic = (Component) => {
	//...do something
	// return a component that renders the component from the argument
	return (props)=> <Component {...props}/>
}
```

### use case 1: enhancing callbacks
```jsx
type ButtonProps = {
  onClick: () => void;
  children: ReactNode;
};
export const Button = ({ onClick, children }: ButtonProps) => {
  return (
    <button onClick={onClick} className="button">
      {children}
    </button>
  );
};

export const withLoggingOnClick = (Component: any) => {
  return (props: any) => {
    const onClick = () => {
      console.info('Log on click something');
      // don't forget to call onClick that is coming from props!
      // we're overriding it below
      props.onClick();
    };

    // return original component with all the props
    // and overriding onClick with our own callback
    return <Component {...props} onClick={onClick} />;
  };
};

export const ButtonWithLoggingOnClick = withLoggingOnClick(Button);

// if we want to log something specific from each ButtonWithLoggingOnClick, we can extract it from props

return ({ logText, ...props }) => {    
	const onClick = () => {      
	// and then just use it here      
		console.log('Log on click: ', logText);
		props.onClick();    
	};
    return <Component {...props} onClick={onClick} />;  
};

// usage
<ButtonWithLogginOnClick logText='hello, world' onClick='...'/>
```
- Note _Button_ itself accepts _onClick_ 

### use case 2: enhancing React life cycle events
```jsx
const withLoggingOnMount = (Component: any) => {
  return (props: any) => {
    // no more overriding onClick
    // use normal useEffect - it's just a component!
    useEffect(() => {
      console.info('log on mount');
    }, []);

    // and pass back props intact
    return <Component {...props} />;
  };
};

const ButtonWithLogginOnMount = withLoggingOnMount(Button)
```

### use case 3: intercepting DOM events
```jsx
const Modal = ({ onClose, children }: { children: ReactNode; onClose: () => void }) => {
  return (
    <div className="modal-dialog">
      <div className="content">{children}</div>
      <div className="footer">
        <Button onClick={onClose}>close dialog</Button>
      </div>
    </div>
  );
};
export const withSuppressKeyPress = (Component: any) => {
  return (props: any) => {
    const onKeyPress = (event: any) => {
      event.stopPropagation();
    };

    return (
    // we need a wrapper div here because Component(e.g Modal) does not accept onKeyPress
      <div onKeyPress={onKeyPress}>
        <Component {...props} />
      </div>
    );
  };
};

const ModalWithSuppressedKeyPress = withSuppressKeyPress(Modal);
```
- Note _keyboard events_ are only generated by `<input>`, `<textarea>`, `<summary>` and anything with the `contentEditable` or `tabindex` attribute. If not caught, they [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling) up the [DOM tree](https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Using_the_Document_Object_Model#what_is_a_dom_tree) until they reach [`Document`](https://developer.mozilla.org/en-US/docs/Web/API/Document). This means we need to have `<input>` or something similar in _Modal_ to make this work.
